"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var begin = {
  s: {
    bottom: 3,
    left: 5.7
  },
  r: {
    bottom: 8.5,
    left: 4,
    peak: 80
  }
};

var sDefaults = {
  bottom: begin.s.bottom,
  left: begin.s.left,
  width: 6,
  height: 9,
  retreating: false,
  pushForce: 1.6,
  retreatSpeed: 2.6
};

var rDefaults = {
  bottom: begin.r.bottom,
  left: begin.r.left,
  width: 17,
  height: 17,
  marginLeft: -3.6,
  peak: 74,
  rollbacks: 0
};
function randomNumber(min, max) {
  return Math.floor(Math.random() * (max - min)) + min;
}

function workThisArray(myArray) {

  var r = Math.floor(Math.random() * myArray.length);
  var message = '';

  myArray[r].forEach(function (k) {
    //console.log(typeof k);
    if ((typeof k === "undefined" ? "undefined" : _typeof(k)) == "object") {
      //console.log(k)
      var z = Math.floor(Math.random() * k.length);

      if (_typeof(k[z]) == "object") {
        k[z].forEach(function (a) {
          if ((typeof a === "undefined" ? "undefined" : _typeof(a)) == "object") {
            message += a[Math.floor(Math.random() * a.length)];
          } else {
            message += a;
          }
        });
      } else {
        message += k[z];
      }
    } else {
      message += k;
    }
  });
  return message;
}

function stringInArray(s, a) {
  var n = a.indexOf(s);
  if (n > -1) {
    return true;
  } else {
    return false;
  }
}

function randomFrom(array) {
  return array[Math.floor(Math.random() * array.length)];
}

function removeFromArray(array, key, value) {
  for (var i = array.length - 1; i >= 0; --i) {
    if (array[i][key] == value) {
      array.splice(i, 1);
    }
  }
}

function findInArray(array, key, value) {
  for (var i = array.length - 1; i >= 0; --i) {
    if (array[i][key] == value) {
      return i;
      //alert(i);
      //break;
    }
  }
}

function shuffle(o) {
  for (var j, x, i = o.length; i; j = Math.floor(Math.random() * i), x = o[--i], o[i] = o[j], o[j] = x) {}
  return o;
}

function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

function bold(string) {
  return '<strong>' + string + '</strong>';
}

function similarity(s1, s2) {
  var longer = s1;
  var shorter = s2;
  if (s1.length < s2.length) {
    longer = s2;
    shorter = s1;
  }
  var longerLength = longer.length;
  if (longerLength == 0) {
    return 1.0;
  }
  return (longerLength - editDistance(longer, shorter)) / parseFloat(longerLength);
}

function editDistance(s1, s2) {
  s1 = s1.toLowerCase();
  s2 = s2.toLowerCase();

  var costs = [];
  for (var i = 0; i <= s1.length; i++) {
    var lastValue = i;
    for (var j = 0; j <= s2.length; j++) {
      if (i == 0) costs[j] = j;else {
        if (j > 0) {
          var newValue = costs[j - 1];
          if (s1.charAt(i - 1) != s2.charAt(j - 1)) newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;
          costs[j - 1] = lastValue;
          lastValue = newValue;
        }
      }
    }
    if (i > 0) costs[s2.length] = lastValue;
  }
  return costs[s2.length];
}

function testChance(chance) {
  var r = Math.floor(Math.random() * 100) + 1;
  if (chance >= r) {
    return true;
  } else {
    return false;
  }
}

function sendEvent(c, a, l, v) {
  if (v) {
    ga('send', 'event', { eventCategory: c, eventAction: a, eventLabel: l, eventValue: v });
    console.log('CATEGORY: ' + c + ', ACTION:' + a + ', LABEL:' + l + ', VALUE:' + v);
  } else if (l) {
    ga('send', 'event', { eventCategory: c, eventAction: a, eventLabel: l });
    console.log('CATEGORY: ' + c + ', ACTION:' + a + ', LABEL:' + l);
  } else {
    ga('send', 'event', { eventCategory: c, eventAction: a });
    console.log('CATEGORY: ' + c + ', ACTION:' + a);
  }
}
var keepPushingMessages = ["Keep going.", "Now keep pushing that rock.", "Okay, continue.", "This time should work.", "Push the rock back up hill.", "You must push the rock uphill.", "Continue pushing the rock uphill."];

var rockFellMessages = ["Oops!", "Uh oh!", "Damn it!", "The rock fell.", "Oh no.", "Crap!", "Well, that's not great."];

var retreatMessages = ["Go back and get it!", "Guess you'll have to go back.", "Back down to the bottom.", "Maybe next time.", "No problem! Just go back.", "Go back down the hill.", "Retrieve the rock", "Okay, back down to the bottom.", "Return for the boulder, Sisyphus.", "You must return for the boulder."];
//@prepros-prepend partials/_variables.js
//@prepros-prepend partials/_functions.js
//@prepros-prepend partials/_phrases.js

//@prepros-append partials/_vue.js
var app = new Vue({
  el: '#app',
  data: {
    phase: 'begin',
    activeTitle: 'none',
    bgPattern: '',
    settings: {
      maxSize: 120
    },
    bg: {
      size: 50,
      fixed: true,
      positionHorizontal: 50,
      positionVertical: 50,
      cover: false,
      show: {
        body: true,
        inner: false,
        headline: false,
        button: false
      }
    },
    currentPattern: null
  },

  methods: {
    setPattern: function setPattern(pattern) {
      var self = this;
      self.currentPattern = pattern;
      self.activeTitle = pattern.title;
      self.bgPattern = "patterns/" + pattern.folder + "/" + pattern.file;
      console.log(pattern.title);
    }
  },

  computed: {
    styleObject: function styleObject() {
      var self = this;
      var s = {};
      if (self.bgPattern) {
        s.backgroundImage = 'url(' + self.bgPattern + ')';
      }
      if (self.bg.size == self.settings.maxSize) {
        s.backgroundSize = 'cover';
      } else if (self.bg.size) {
        s.backgroundSize = self.bg.size + '%';
      }

      if (self.bg.positionHorizontal == 50 && self.bg.positionVertical == 50) {
        s.backgroundPosition = 'center';
      } else {
        s.backgroundPosition = self.bg.positionHorizontal + '% ' + self.bg.positionVertical + '%';
        console.log(s);
      }
      return s;
    },
    coolCSS: function coolCSS() {
      var self = this;
      var pre = '.cool {\n';
      if (self.bgPattern) {
        pre += '  background-image:url(' + self.bgPattern + ');\n';
      }

      if (self.bg.size == self.settings.maxSize) {
        pre += '  background-size: cover;\n';
      } else if (self.bg.size) {
        pre += '  background-size: ' + self.bg.size + '%;\n';
      }

      if (self.bg.positionHorizontal == 50 && self.bg.positionVertical == 50) {
        pre += '  background-position: center\n';
      } else {
        pre += '  background-position: ' + self.bg.positionHorizontal + '% ' + self.bg.positionVertical + '%\n';
      }

      pre += '}';

      // HEADLINE SPECIFIC STYLES
      if (self.bg.show.headline) {
        pre += '\n\nh1.cool {\n';
        pre += '  background-clip: text;\n';
        pre += '  -webkit-text-fill-color: transparent;\n';
        pre += '}';
      }
      // BUTTON SPECIFIC STYLES
      if (self.bg.show.button) {
        pre += '\n\nbutton.cool {\n';
        pre += '  transition:background-size 0.5s ease;\n';
        pre += '}';
        pre += '\n\nbutton.cool:hover, button.cool:focus {\n';
        pre += '  background-size: ' + self.bg.size * 2 + '%;\n';
        pre += '}';
      }

      return pre;
    }
  },

  mounted: function mounted() {
    var self = this;
  }

});
//# sourceMappingURL=bg2cool.min.js.map