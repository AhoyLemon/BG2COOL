"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var siteURL = "http://bg2.cool";

var begin = {
  s: {
    bottom: 3,
    left: 5.7
  },
  r: {
    bottom: 8.5,
    left: 4,
    peak: 80
  }
};

var sDefaults = {
  bottom: begin.s.bottom,
  left: begin.s.left,
  width: 6,
  height: 9,
  retreating: false,
  pushForce: 1.6,
  retreatSpeed: 2.6
};

var rDefaults = {
  bottom: begin.r.bottom,
  left: begin.r.left,
  width: 17,
  height: 17,
  marginLeft: -3.6,
  peak: 74,
  rollbacks: 0
};
function randomNumber(min, max) {
  return Math.floor(Math.random() * (max - min)) + min;
}

function workThisArray(myArray) {

  var r = Math.floor(Math.random() * myArray.length);
  var message = '';

  myArray[r].forEach(function (k) {
    //console.log(typeof k);
    if ((typeof k === "undefined" ? "undefined" : _typeof(k)) == "object") {
      //console.log(k)
      var z = Math.floor(Math.random() * k.length);

      if (_typeof(k[z]) == "object") {
        k[z].forEach(function (a) {
          if ((typeof a === "undefined" ? "undefined" : _typeof(a)) == "object") {
            message += a[Math.floor(Math.random() * a.length)];
          } else {
            message += a;
          }
        });
      } else {
        message += k[z];
      }
    } else {
      message += k;
    }
  });
  return message;
}

function stringInArray(s, a) {
  var n = a.indexOf(s);
  if (n > -1) {
    return true;
  } else {
    return false;
  }
}

function randomFrom(array) {
  return array[Math.floor(Math.random() * array.length)];
}

function removeFromArray(array, key, value) {
  for (var i = array.length - 1; i >= 0; --i) {
    if (array[i][key] == value) {
      array.splice(i, 1);
    }
  }
}

function findInArray(array, key, value) {
  for (var i = array.length - 1; i >= 0; --i) {
    if (array[i][key] == value) {
      return i;
      //alert(i);
      //break;
    }
  }
}

/*
function formatDate(d) {
  const allMonths = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December' ]
  const MonthAbbr = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec' ]
  let e = d.split("-");
  return MonthAbbr[parseInt(e[1] - 1)] + ' ' + e[2] + ', ' + e[0];
}
*/

function shuffle(o) {
  for (var j, x, i = o.length; i; j = Math.floor(Math.random() * i), x = o[--i], o[i] = o[j], o[j] = x) {}
  return o;
}

function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

function bold(string) {
  return '<strong>' + string + '</strong>';
}

function similarity(s1, s2) {
  var longer = s1;
  var shorter = s2;
  if (s1.length < s2.length) {
    longer = s2;
    shorter = s1;
  }
  var longerLength = longer.length;
  if (longerLength == 0) {
    return 1.0;
  }
  return (longerLength - editDistance(longer, shorter)) / parseFloat(longerLength);
}

function editDistance(s1, s2) {
  s1 = s1.toLowerCase();
  s2 = s2.toLowerCase();

  var costs = [];
  for (var i = 0; i <= s1.length; i++) {
    var lastValue = i;
    for (var j = 0; j <= s2.length; j++) {
      if (i == 0) costs[j] = j;else {
        if (j > 0) {
          var newValue = costs[j - 1];
          if (s1.charAt(i - 1) != s2.charAt(j - 1)) newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;
          costs[j - 1] = lastValue;
          lastValue = newValue;
        }
      }
    }
    if (i > 0) costs[s2.length] = lastValue;
  }
  return costs[s2.length];
}

function testChance(chance) {
  var r = Math.floor(Math.random() * 100) + 1;
  if (chance >= r) {
    return true;
  } else {
    return false;
  }
}

function sendEvent(c, a, l, v) {
  if (v) {
    ga('send', 'event', { eventCategory: c, eventAction: a, eventLabel: l, eventValue: v });
    console.log('CATEGORY: ' + c + ', ACTION:' + a + ', LABEL:' + l + ', VALUE:' + v);
  } else if (l) {
    ga('send', 'event', { eventCategory: c, eventAction: a, eventLabel: l });
    console.log('CATEGORY: ' + c + ', ACTION:' + a + ', LABEL:' + l);
  } else {
    ga('send', 'event', { eventCategory: c, eventAction: a });
    console.log('CATEGORY: ' + c + ', ACTION:' + a);
  }
}
var keepPushingMessages = ["Keep going.", "Now keep pushing that rock.", "Okay, continue.", "This time should work.", "Push the rock back up hill.", "You must push the rock uphill.", "Continue pushing the rock uphill."];

var rockFellMessages = ["Oops!", "Uh oh!", "Damn it!", "The rock fell.", "Oh no.", "Crap!", "Well, that's not great."];

var retreatMessages = ["Go back and get it!", "Guess you'll have to go back.", "Back down to the bottom.", "Maybe next time.", "No problem! Just go back.", "Go back down the hill.", "Retrieve the rock", "Okay, back down to the bottom.", "Return for the boulder, Sisyphus.", "You must return for the boulder."];
//@prepros-prepend partials/_variables.js
//@prepros-prepend partials/_functions.js
//@prepros-prepend partials/_phrases.js

//@prepros-append partials/_vue.js
var app = new Vue({
  el: '#app',
  data: {
    phase: 'begin',
    activeTitle: 'none',
    bgPattern: '',
    settings: {
      maxSize: 120
    },
    formURL: null,
    copyMatch: null,
    bg: {
      pattern: null,
      title: null,
      size: 50,
      fixed: true,
      positionHorizontal: 50,
      positionVertical: 50,
      cover: false,
      localFile: true,
      borders: {
        width: 20,
        slice: 10
      },
      show: {
        body: true,
        inner: false,
        headline: true,
        button: false,
        borders: false
      }
    },
    currentPattern: null
  },

  methods: {
    setPattern: function setPattern(pattern) {
      var self = this;
      self.phase = 'browse patterns';
      self.cssCopied = false;

      self.currentPattern = pattern;
      self.activeTitle = pattern.title;

      self.bgPattern = "patterns/" + pattern.folder + "/" + pattern.file;
      console.log(pattern.title);

      self.bg.title = pattern.title;
      self.bg.pattern = "patterns/" + pattern.folder + "/" + pattern.file;
    },
    copyCSS: function copyCSS() {

      var self = this;

      var copyText = document.getElementById("CopyCode").textContent;
      var textArea = document.createElement('textarea');
      textArea.textContent = copyText;
      document.body.append(textArea);
      textArea.select();
      document.execCommand("copy");
      textArea.remove();

      self.copyMatch = self.coolCSS;
    },
    gForm: function gForm(u, t) {
      var self = this;
      //self.phase = "show form";
      self.formURL = u;

      if (t == "blank") {
        window.open(self.formURL);
      }
    },
    formatDate: function formatDate(d) {
      var allMonths = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
      var MonthAbbr = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      var e = d.split("-");
      return MonthAbbr[parseInt(e[1] - 1)] + ' ' + e[2] + ', ' + e[0];
    }
  },

  computed: {
    styleObject: function styleObject() {
      var self = this;
      var s = {};
      if (self.bgPattern) {
        s.backgroundImage = 'url(' + self.bg.pattern + ')';
      }
      if (self.bg.size == self.settings.maxSize) {
        s.backgroundSize = 'cover';
      } else if (self.bg.size) {
        s.backgroundSize = self.bg.size + '%';
      }

      if (self.bg.positionHorizontal == 50 && self.bg.positionVertical == 50) {
        s.backgroundPosition = 'center';
      } else {
        s.backgroundPosition = self.bg.positionHorizontal + '% ' + self.bg.positionVertical + '%';
        console.log(s);
      }

      if (self.bg.show.borders) {
        s.borderImageSource = 'url(' + self.bg.pattern + ')';
        s.borderWidth = self.bg.borders.width + 'px';
        s.borderImageSlice = self.bg.borders.slice + '%';
      }

      return s;
    },
    coolCSS: function coolCSS() {
      var self = this;
      var pre = "";

      var patternURL = "";
      if (self.bg.localFile) {
        //patternURL = self.bg.pattern;
        var p = self.bg.pattern.split("/");
        patternURL = p[p.length - 1];
      } else {
        patternURL = '"' + siteURL + '/' + self.bg.pattern + '"';
      }

      // GENERIC COOL BG STYLE
      if (self.bg.show.body || self.bg.show.headline || self.bg.show.inner || self.bg.show.button) {

        pre += '.cool {\n';
        if (self.bg.pattern) {
          pre += '  background-image:url(' + patternURL + ');\n';
        }

        if (self.bg.size == self.settings.maxSize) {
          pre += '  background-size: cover;\n';
        } else if (self.bg.size) {
          pre += '  background-size: ' + self.bg.size + '%;\n';
        }

        if (self.bg.positionHorizontal == 50 && self.bg.positionVertical == 50) {
          pre += '  background-position: center\n';
        } else {
          pre += '  background-position: ' + self.bg.positionHorizontal + '% ' + self.bg.positionVertical + '%\n';
        }

        pre += '}';
      }

      // HEADLINE SPECIFIC STYLES
      if (self.bg.show.headline) {
        pre += '\n\nh1.cool {\n';
        pre += '  background-clip: text;\n';
        pre += '  -webkit-text-fill-color: transparent;\n';
        pre += '}';
      }

      // BUTTON SPECIFIC STYLES
      if (self.bg.show.button) {
        pre += '\n\nbutton.cool {\n';
        pre += '  transition:background-size 0.5s ease;\n';
        pre += '}';
        pre += '\n\nbutton.cool:hover, button.cool:focus {\n';
        pre += '  background-size: ' + self.bg.size * 2 + '%;\n';
        pre += '}';
      }

      // BORDER STYLES
      if (self.bg.show.borders) {
        pre += '\n\n.cool-borders {\n';
        pre += '  border-image-source: url(' + patternURL + ');\n';
        pre += '  border-width: ' + self.bg.borders.width + 'px;\n';
        pre += '  border-image-slice: ' + self.bg.borders.slice + '%;\n';
        pre += '  border-image-repeat: round;\n';
        pre += '}';
      }

      return pre;
    },
    cssCopyMatch: function cssCopyMatch() {
      var self = this;
      if (self.coolCSS == self.copyMatch) {
        return true;
      } else {
        return false;
      }
    }
  },

  mounted: function mounted() {
    var self = this;
  }

});
//# sourceMappingURL=bg2cool.min.js.map